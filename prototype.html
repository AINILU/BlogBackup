<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta http-equiv="X-UA-Compatible" content="ie=edge">
    <title>Document</title>
</head>
<body>
    <script type="text/javascript">
        // 对象_proto_属性的值就是他的原型对象
        var one = {x: 1};
        var two = new Object();
        console.log(one.__proto__ === Object.prototype );// true
        two.__proto__ === Object.prototype // true
        one.toString === one.__proto__.toString //true

        // 只有函数才有prototype属性。
        // 当你创建函数时，JS会为这个函数自动添加prototype属性，
        // 值是空对象。而一旦你把这个函数当作构造函数（constructor）调用（即通过new关键字调用），
        // 那么JS就会帮你创建该构造函数的实例，实例继承构造函数prototype的所有属性和方法
        // （实例通过设置自己的__proto__指向承构造函数的prototype来实现这种继承.
        // 构造函数，通过prototype来存储要共享的属性和方法，也可以设置prototype指向现存的对象来继承该对象。

// 对象的__proto__指向自己构造函数的prototype。obj.__proto__.__proto__...的原型链由此产生
// ，包括我们的操作符instanceof正
// 是通过探测obj.__proto__.__proto__... === Constructor.prototype来验证obj是否是Constructor的实例。

    </script>
</body>
</html>
